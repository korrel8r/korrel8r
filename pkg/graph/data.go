// Copyright: This file is part of korrel8r, released under https://github.com/korrel8r/korrel8r/blob/main/LICENSE

package graph

import (
	"fmt"

	"github.com/korrel8r/korrel8r/pkg/korrel8r"
	"gonum.org/v1/gonum/graph"
	"gonum.org/v1/gonum/graph/multi"
)

// Data contains a set of class nodes and rule lines to be used in rule/class graphs.
// Graphs based on the same Data have consistent node and line IDs.
//
// Concurrency: Data is immutable once created.
type Data struct {
	Nodes  []*Node          // Nodes slice index == Node.ID()
	Lines  []*Line          // Lines slice index == Line.ID()
	nodeID map[string]int64 // Map by full class name
}

// NewData creates a new data set from a list of rules.
//
// Concurrency: Data is immutable once created.
func NewData(rules ...korrel8r.Rule) *Data {
	d := Data{nodeID: make(map[string]int64)}
	for _, r := range rules {
		d.addRule(r)
	}
	return &d
}

func (d *Data) addRule(r korrel8r.Rule) {
	for _, start := range r.Start() {
		for _, goal := range r.Goal() {
			id := int64(len(d.Lines))
			l := &Line{
				Line:    multi.Line{F: d.addClass(start), T: d.addClass(goal), UID: id},
				Rule:    r,
				Attrs:   Attrs{},
				Queries: Queries{},
			}
			d.Lines = append(d.Lines, l)
		}
	}
}

// addClass creates a node for c or returns the existing node.
func (d *Data) addClass(c korrel8r.Class) *Node {
	if n := d.NodeFor(c); n != nil {
		return n
	}
	id := int64(len(d.Nodes))
	n := &Node{
		Node:    multi.Node(id),
		Class:   c,
		Attrs:   Attrs{},
		Result:  NewResult(c),
		Queries: Queries{},
	}
	d.Nodes = append(d.Nodes, n)
	d.nodeID[c.String()] = id
	return n
}

// NodeFor returns the Node for class c, or nil if absent.
func (d *Data) NodeFor(c korrel8r.Class) *Node {
	if id, ok := d.nodeID[c.String()]; ok {
		return d.Nodes[id]
	}
	return nil
}

// EmptyGraph returns a new emptpy graph.
func (d *Data) EmptyGraph() *Graph { return New(d) }

// FullGraph returns a new graph of all the Data.
func (d *Data) FullGraph() *Graph {
	g := New(d)
	for _, l := range d.Lines {
		g.SetLine(l)
	}
	for _, n := range d.Nodes {
		if nn := g.Node(n.ID()); nn == nil {
			g.AddNode(n)
		} else if nn != n {
			panic(fmt.Errorf("invalid node %v, already have %v", n, nn))
		}
	}
	return g
}

// Rules returns a copy of the complete list of rules.
func (d *Data) Rules() []korrel8r.Rule {
	var rules []korrel8r.Rule
	for _, l := range d.Lines {
		rules = append(rules, l.Rule)
	}
	return rules
}

// Classes returns a copy of the complete list of classes.
func (d *Data) Classes() []korrel8r.Class {
	var classs []korrel8r.Class
	for _, n := range d.Nodes {
		classs = append(classs, n.Class)
	}
	return classs
}

// Node is a graph Node, contains a Class.
type Node struct {
	multi.Node
	Attrs   // GraphViz Attributer
	Class   korrel8r.Class
	Result  Result  // Accumulate incoming query results.
	Queries Queries // All queries leading to this node.

	Value any // Value is an extra value that can be stored on a node.
}

func NodeFor(n graph.Node) *Node           { return n.(*Node) }
func ClassFor(n graph.Node) korrel8r.Class { return NodeFor(n).Class }

func (n *Node) String() string { return n.Class.String() }
func (n *Node) DOTID() string  { return n.Class.String() }
func (n *Node) Empty() bool    { return len(n.Result.List()) == 0 }

// QueryCount records count of objects resulting from a query.
// Count == -1 means the query has not been evaluated.
type QueryCount struct {
	Query korrel8r.Query
	Count int
}

// Queries is a map of QueryCount by Query name.
type Queries map[string]QueryCount

func (qs Queries) Has(q korrel8r.Query) bool   { _, ok := qs[q.String()]; return ok }
func (qs Queries) Set(q korrel8r.Query, n int) { qs[q.String()] = QueryCount{q, n} }
func (qs Queries) Get(q korrel8r.Query) int {
	if qc, ok := qs[q.String()]; ok {
		return qc.Count
	}
	return -1
}

// Total of the counts
func (qs Queries) Total() (total int) {
	for _, qc := range qs {
		if qc.Count > 0 { // Don't count -1 (unevaluated)
			total += qc.Count
		}
	}
	return total
}

// Line is one line in a multi-graph edge, corresponds to a rule.
type Line struct {
	multi.Line
	Attrs   // GraphViz Attributer
	Rule    korrel8r.Rule
	Queries Queries // Queries generated by Rule
}

func (l *Line) String() string { return fmt.Sprintf("%q(%v->%v)", l.Rule.Name(), l.From(), l.To()) }
func (l *Line) DOTID() string  { return l.Rule.Name() }
func (l *Line) Start() *Node   { return NodeFor(l.Line.From()) }
func (l *Line) Goal() *Node    { return NodeFor(l.Line.To()) }

func LineFor(l graph.Line) *Line         { return l.(*Line) }
func RuleFor(l graph.Line) korrel8r.Rule { return LineFor(l).Rule }

type Edge multi.Edge

func (e *Edge) Start() *Node { return e.F.(*Node) }
func (e *Edge) Goal() *Node  { return e.T.(*Node) }
func (e *Edge) EachLine(visit func(*Line)) {
	lines := e.Lines
	for lines.Next() {
		visit(lines.Line().(*Line))
	}
}
