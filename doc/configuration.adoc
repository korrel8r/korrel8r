[id="configuration"]
= Configuration
:xref-domain: xref:index.adoc#index-domain-reference[Domain Reference]
:go-templates: https://pkg.go.dev/text/template[Go templates]
:pkg-korrel8r: https://pkg.go.dev/github.com/korrel8/korrel8/pkg/korrel8
:slim-sprig: https://go-task.github.io/slim-sprig[slim-sprig]

include::attributes.adoc[]

Korrel8r loads configuration from the file specified by the `--config` flag:

[source,terminal]
----
$ korrel8r --config <path_to_config_file>
----

The default configuration can be loaded from the internet:
----
korrel8r -c https://raw.githubusercontent.com/korrel8r/korrel8r/main/etc/korrel8r/korrel8r.yaml get
----

[TIP]
====
You can examine the default configuration files at the Korrel8r project provides some link:{etc-korrel8r}[example configuration files]
====

The configuration file is a YAML file with the following sections:

[source,yaml]
.Include paths to other configuratoin files to include in this one.
----
include:
  - "path_to_config_file"
----

.Stores defines how to connect to data stores. See xref:_stores[].
[source,yaml]
----
stores:
  - domain: "domain_name" <1>
    # Domain-specific fields <2>
----

<1> Domain name of the store (required).
<2> Domain-specific fields for connection parameters. See {xref-domain}.

.Rules defines rules to relate different classes of data. See xref:_rules[].
[source,yaml]
----
rules:
  - name: "rule_name" <1>
    start: <2>
      domain: "domain_name"
      classes:
        - "class_name"
    goal: <3>
      domain: "domain_name"
      classes:
        - "class_name"
    result:
      query: "query_template" <4>
----

<1> Name identifies the rule in graphs and for debugging.
<2> Start objects for this rule must belong to one of the `classes` in the `domain`.
<3> Goal queries generated by this rule may must retrieve one of the `classes` in the `domain`.
<4> Result queries are generated by executing the `query` xref:_templates[template] with the start object as context.

.Aliases is a list of short-hand alias names for groups of rules.
[source,yaml]
----
aliases:
  - name: "alias_name" <1>
    domain: "domain_name" <2>
    classes: <3>
      - "class_name"
----

<1> Alias name can be used as a class name in rule definitions.
<2> Domain for classes in this alias.
<3> Classes belonging to this alias.

== Stores

Every entry in the `stores` section has a `domain` field to identify the domain.
Other fields depend on the domain, see {xref-domain}.
Store fields can contain URL strings or templates to compute URLs at run-time.

[source,yaml]
.Example: configuring a store URL from an Openshift Route resource.
----
stores:
  - domain: log
    lokiStack: |-
      {{- $routes := (get "k8s:Route:{namespace: openshift-logging, name: logging-loki}") -}} <1>
      {{- $route = first $routes -}} <2>
      https://{{$route.Spec.Host -}} <3>
----

<1> Get returns a list of routes in the "openshift-logging" namespace named "logging-loki".
<2> `first` is a {slim-sprig} function that returns the first element of the list.
<3> The template uses the .Spec.Host field for the URL.

== Rules

A rule has the following key elements:

* A set of _start_ classes. The rule can apply to objects belonging to one of these classes.
* A set of _goal_ classes. The rule can generate queries for any of these classes.
* A result query xref:_templates[template] that generates a goal query from a start object.

The query template should generate a string of the form:

----
<domain-name>:<class-name>:<query-details>
----

The _query-details_ part depends on the domain, see {xref-domain}

.Example of rules and aliases.
[source,yaml]
----
aliases:
  - name: namespacedResources <1>
    domain: k8s
    classes:
      - Pod
      - Deployment.apps
      # ... [snip] lists other goal classes for the NamespaceToResource rule

rules:
   - name: NamespaceToResource <2>
     start:
       domain: k8s
       classes: [Namespace]
     goal:
       domain: k8s
       classes: [namespacedResources] <3>
     result:
       query: '{{rule.Goal}}:{namespace: {{.Name -}} }'  <4>
----

<1> The alias "namespacedResources" includes multiple k8s classes representing namespace resources.
<2> This rule relates namespaces to resources in the namespace.
<3> The query template uses `{{rule.Goal}}` to get the actual goal class. See xref:_templates[].
It  selects objects with namespace of `.Name`, the name field of the current start object which is a namespace.
Note the capitalization, k8s queries operate on deserialized Go objects representing resources.

== Templates

Some fields in the `stores` and `rules` section are {go-templates}.
This is the same template syntax used by the Kubernetes `kubectl` tool with the `--output=template` option.
Korrel8r provides some additional _template functions_ that can be used in configuration templates.

.Additional template functions
****
rule::

Returns the link:{pkg-korrel8r}#Rule[korrel8r.Rule] object being applied, available in rule query templates only.
This is useful for rules that have more than one possible goal class, the current goal class is `{{rule.Goal}}`
See xref:_rules[] for an example.

get QUERY::
Executes QUERY and returns a list of result objects.
Used to dynamically configuration stores at run-time, see xref:_stores[] for an example.

{slim-sprig} is a library of general-purpose functions that are always available.

Domain-specific functions are documented in {xref-domain}.
****
